package uli.nick.job4j.praxis.tasks116array;

/**
 * <p>4.3. Кинотеатр
 * <p>Метод принимает двумерный массив объектов Place, в котором есть 2 поля:
 * <p>1. int row - ряд в кинотеатре;
 * <p>2. int cell - место в этом ряду.
 * <p>Т.е. массив имитирует рассадку посетителей в кинотеатре. При этом если значение равно null - значит место
 * свободно, иначе - место зарезервировано.
 * <p>При этом рассадить посетителей нужно так, чтобы рядом значения null могли быть только по диагонали.
 * Поясним на примере(X - занятое место, O - пустое место):
 * <p>1 вариант
 * <p>{X, O, X}
 * <p>{O, X, O}   -   по такой схеме еще одного посетителя добавить нельзя.
 * <p>{X, O, X}
 * <p>2 вариант:
 * <p>{O, O, X}
 * <p>{O, X, O}   -   по такой схеме еще один посетитель может занять клетку с координатами 0, 0
 * <p>{X, O, X}
 * <p>3 вариант
 * <p>{X, O, X}
 * <p>{O, O, O}   -   по такой схеме еще один посетитель может занять клетку с координатами 1, 1
 * <p>{X, O, X}
 * <p>Метод должен вернуть клетку в которую можно разместить нового посетителя, при этом если таких клеток
 * будет несколько - нужно вернуть первую из них. Метод должен работать с любым набором исходных данных.
 */

public class Cinema {
    public static int[] checkEmptyPlace(char[][] places) {
        int l = places.length;
        for (int i = 0; i < l; i++) {
            for (int j = 0; j < l; j++) {
                if (places[i][j] != 'X'
                        && (i - 1 < 0 || places[i - 1][j] == 'O') && (i + 1 == l || places[i + 1][j] == 'O')
                        && (j - 1 < 0 || places[i][j - 1] == 'O') && (j + 1 == l || places[i][j + 1] == 'O')) {
                    return new int[]{i, j};
                }
            }
        }
        return new int[]{};
    }
}

// Каркас 4.3.:
//public class Cinema {
//    public static int[] checkEmptyPlace(char[][] places) {
//        return new int[] {};
//    }
//}
//.
